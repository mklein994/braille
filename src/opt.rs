use crate::util;
use crate::{InputLine, InputLineSinglable, InputLines, LineResult};
use clap::{builder::BoolishValueParser, Command, Parser, ValueEnum};
use std::{fmt, str::FromStr};

#[derive(Debug, Copy, Clone, Default)]
#[cfg_attr(test, derive(PartialEq))]
struct GraphRangeBound(Option<f64>);

impl fmt::Display for GraphRangeBound {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.map(|x| x.to_string()).unwrap_or_default().fmt(f)
    }
}

#[derive(Debug, Copy, Clone, Default)]
#[cfg_attr(test, derive(PartialEq))]
pub struct GraphRange {
    min: GraphRangeBound,
    max: GraphRangeBound,
}

impl GraphRange {
    fn try_new(min: Option<f64>, max: Option<f64>) -> anyhow::Result<Self> {
        if let (Some(min), Some(max)) = (min, max) {
            Opt::validate_bounds(min, max)?;
        }

        Ok(Self {
            min: GraphRangeBound(min),
            max: GraphRangeBound(max),
        })
    }

    pub fn min(&self) -> Option<f64> {
        self.min.0
    }

    pub fn max(&self) -> Option<f64> {
        self.max.0
    }
}

impl fmt::Display for GraphRange {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}:{}", self.min, self.max)
    }
}

impl FromStr for GraphRange {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if s == ":" {
            return Ok(Self::default());
        }

        if !s.contains(':') {
            anyhow::bail!("Range should contain ':'");
        }

        let maybe_parse = |value: &str| -> Result<Option<f64>, <f64 as FromStr>::Err> {
            if value.is_empty() {
                Ok(None)
            } else {
                Ok(Some(value.parse()?))
            }
        };

        let (min, max) = {
            let (min, max) = s.split_once(':').expect("should split on ':'");
            (maybe_parse(min)?, maybe_parse(max)?)
        };

        Self::try_new(min, max)
    }
}

/// Fill the space between series when the first is less or equal to the second value (or zero
/// if `--per` is 1), and hollow otherwise
///
/// # Example
///
/// ## One value per line (`--per 1`, `-p1`, the default)
///
/// Let's say we have a series of numbers generated by the following `jq` script:
///
/// ```jq
#[doc = include_str!("../tests/curve-1.jq")]
/// ```
///
/// ### Auto (`--style auto`, `-sa`)
///
/// ```console
/// $ jq -rnf curve-1.jq | braille -c 10 -sa
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ
/// ‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°á
/// ‚†â‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†å‚†Å
/// ‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚°à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†à‚°Ä‚†Ä‚†Ä‚††‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä‚†Ä‚†Ä‚°ê‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†ê‚¢Ñ‚°†‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†°‚£Ä‚†î‚†Ä‚†Ä‚†Ä‚†Ä
/// ```
///
/// ### Line (`--style line`, `-sl`)
///
/// ```console
/// $ jq -rnf curve-1.jq | braille -c 10 -sl
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†â‚†ë‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Å‚†Ä‚†Ä‚††‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ
/// ‚†ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä
/// ‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ä
/// ‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚°à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†à‚°Ä‚†Ä‚†Ä‚††‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä‚†Ä‚†Ä‚°ê‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†ê‚¢Ñ‚°†‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†°‚£Ä‚†î‚†Ä‚†Ä‚†Ä‚†Ä
/// ```
///
/// ### Filled (`--style filled`, `-sf`)
///
/// ```console
/// $ jq -rnf curve-1.jq | braille -c 10 -sf
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ
/// ‚£∑‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°á
/// ‚†â‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚†â‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†è‚†Å
/// ‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚°è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚£ø‚£ø‚£ø‚†á‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†à‚£ø‚£ø‚£ø‚°ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†ò‚¢ø‚°ø‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä
/// ```
///
/// ## Two values per line (`--per 2`, `-p2`)
///
/// ```jq
/// # curve-1.jq
/// (-1 | acos) as $pi
/// | range(-8 * $pi; 8 * $pi)
/// | . / 5
/// | cos
/// ```
///
/// ### Auto (`--style auto`, `-sa`)
///
/// ```console
/// $ jq -rnf curve-2.jq | braille -p2 -c 10 -sa
/// ‚†Ä‚†Ä‚£∞‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†â‚†ë‚£Ä‚£æ‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚¢†‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Å‚†Ä‚†Ä‚°∏‚£ø‚£ø‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚£º‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚¢Ä‚†Ä‚¢ª‚£ø‚£ø‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚¢Ç‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†à‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ
/// ‚°ò‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢π‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä
/// ‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ß‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ç
/// ‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Å‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚††‚††‚†Ä
/// ‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£è‚†Ä‚†Ä‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ñ‚†Ñ‚†Ä
/// ‚†Ä‚†Ä‚†à‚£ø‚£ø‚£ø‚°ø‚†Ä‚†Ñ‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ß‚†Ä‚°ê‚††‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†ò‚¢ø‚°ø‚†Å‚†Ä‚†ê‚£Ä‚†å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£ø‚†∂‚°†‚†Ç‚†Ä‚†Ä
/// ```
///
/// ### Line (`--style line`, `-sl`)
///
/// ```console
/// $ jq -rnf curve-2.jq | braille -p2 -c 10 -sl
/// ‚†Ä‚†Ä‚°ê‚†â‚†Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†â‚†ë‚£Ä‚†ä‚†°‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚††‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Å‚†Ä‚†Ä‚°†‚†Ä‚†Ä‚¢Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚†Ñ‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ç‚†Ä‚†Ä‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚¢Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ
/// ‚°ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Å‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä
/// ‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†à‚†Ä‚†Ä‚†Ä‚†à‚°Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Ç
/// ‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ñ‚†Å‚†Ä‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†Ä‚††‚†Ä‚†Ä‚†Ä‚††‚††‚†Ä
/// ‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚£à‚†Ä‚†Ä‚†Ä‚†ê‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ä‚†Ä‚†Ñ‚†Ä‚†Ä‚†Ñ‚†Ñ‚†Ä
/// ‚†Ä‚†Ä‚†à‚°Ä‚†Ä‚†Ä‚††‚†Ä‚†Ñ‚†Ä‚†Ä‚†Ç‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†Ä‚††‚†Ä‚°ê‚††‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†ê‚¢Ñ‚°†‚†Å‚†Ä‚†ê‚£Ä‚†å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†°‚£Ä‚†∂‚°†‚†Ç‚†Ä‚†Ä
/// ```
///
/// ### Filled (`--style filled`, `-sf`)
///
/// ```console
/// $ jq -rnf curve-2.jq | braille -p2 -c 10 -sf
/// ‚†Ä‚†Ä‚£∞‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£∑‚£Ä‚£æ‚£ß‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚¢†‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚°ø‚£ø‚£ø‚£á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚†Ä‚£º‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚†Ä‚¢ª‚£ø‚£ø‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
/// ‚£Ü‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚¢∞‚£ø‚£ø‚£ø‚°á‚†Ä‚†à‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ
/// ‚°ü‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚¢π‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°á
/// ‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ß‚†Ä‚¢∞‚£ø‚£ø‚£ø‚°è‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ø‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä‚£º‚†É
/// ‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚°Ñ‚£ø‚£ø‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ß‚†Ä‚†Ä‚†Ä‚¢†‚°ø‚†Ä
/// ‚†Ä‚†Ä‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚£º‚†á‚†Ä
/// ‚†Ä‚†Ä‚†à‚£ø‚£ø‚£ø‚°ø‚†Ä‚¢ø‚£ø‚£ø‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ß‚†Ä‚£∞‚°ø‚†Ä‚†Ä
/// ‚†Ä‚†Ä‚†Ä‚†ò‚¢ø‚°ø‚†Å‚†Ä‚†ò‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†π‚£ø‚†∂‚°ø‚†É‚†Ä‚†Ä
/// ```
#[derive(Debug, Default, ValueEnum, Clone, Copy)]
pub enum GraphStyle {
    /// Fill the area between values in a series, or the value above zero if only one is provided
    ///
    /// When `--per 2`, if the second value is less than the first, the graph will be hollow,
    /// otherwise the area between them is filled.
    #[value(alias = "a")]
    Auto,

    /// Never fill between series (show each field independently as a line)
    #[value(alias = "l")]
    Line,

    /// Always fill the space between multiple series (or the area above zero if only one was
    /// given)
    #[default]
    #[value(alias = "f")]
    Filled,
}

#[derive(Debug, Parser)]
#[command(version)]
#[allow(clippy::struct_excessive_bools)]
pub struct Opt {
    /// The input's minimum and maximum values
    ///
    /// If provided, at least one of `MIN` or `MAX` must be given.
    ///
    /// # Example
    ///
    /// ```plain
    /// --range -3:4  # Use bounds given
    /// --range -3:   # Automatically determine maximum
    /// --range :4    # Automatically determine minimum
    /// ```
    #[arg(
        short,
        long,
        alias = "bounds",
        verbatim_doc_comment,
        allow_hyphen_values = true,
        default_value_t,
        hide_default_value = true,
        value_name = "[MIN]:[MAX]"
    )]
    range: GraphRange,

    /// Number of values per line of input
    ///
    /// When the graph kind supports it, each value represents a separate series.
    #[arg(short, long, default_value_t = 1, value_parser(clap::value_parser!(u8).range(1..)))]
    pub per: u8,

    /// How the space between multiple series should be handled
    #[arg(short, long, value_enum, default_value_t)]
    pub style: GraphStyle,

    /// Determine the dimensions of the braille grid in dots (width and height)
    ///
    /// Passing no arguments means the smaller of either width or height will be used (to make it
    /// square without cropping or stretching). Respects --use-full-default-height. If one value is
    /// passed, it's interpreted as both width and height.
    #[arg(short, num_args(0..=2))]
    pub grid: Option<Vec<u16>>,

    /// Shorthand for setting -x and -y to the same value
    ///
    /// e.g. -G -1:1 is the same as -x -1:1 -y -1:1
    #[arg(short = 'G', long, allow_hyphen_values = true)]
    pub grid_bounds: Option<GraphRange>,

    #[arg(short, long, allow_hyphen_values = true)]
    pub x_bounds: Option<GraphRange>,

    #[arg(short, long, allow_hyphen_values = true)]
    pub y_bounds: Option<GraphRange>,

    /// Interpret arguments from the very first line of the input
    ///
    /// If this is passed, then the first line from standard input should match the following:
    ///
    /// ```plain
    /// braille [OPTIONS] [ARGUMENTS]
    /// [VALUES...]
    /// ```
    ///
    /// Where `OPTIONS` and `ARGUMENTS` are space separated values as you would pass them on the
    /// command line, and `VALUES` are the values you want to graph.
    ///
    /// # Example
    ///
    /// `input.txt`
    ///
    /// ```plain
    /// braille -r -3:4 4
    /// -3
    /// -2
    /// -1
    /// 0
    /// 1
    /// 2
    /// 3
    /// 4
    /// ```
    ///
    /// ## Command
    ///
    /// ```console
    /// cat input.txt | braille --modeline
    /// ```
    ///
    /// ## Output
    ///
    /// ```plain
    /// ‚†ô‚¢ø
    /// ‚†Ä‚¢∏‚£∑‚£Ñ
    /// ```
    #[arg(
        short,
        long,
        conflicts_with_all = [
            "range",
            "file",
            "kind",
            "size",
        ],
        verbatim_doc_comment
    )]
    pub modeline: bool,

    /// The kind of graph to print
    ///
    /// Kinds supported with their matching option parameters:
    ///
    /// | Kind    | Bar (horizontal)   | Column (vertical)        |
    /// |---------|--------------------|--------------------------|
    /// | Braille | `braille` (`-b`)   | `braille-columns` (`-c`) |
    /// | Block   | `bars` (`-B`)      | `columns` (`-C`)         |
    #[arg(
        short = 'k',
        long = "kind",
        group = "kind",
        value_enum,
        default_value_t,
        verbatim_doc_comment
    )]
    graph_kind: GraphKind,

    /// Shortcut for --kind bars
    #[arg(short = 'B', group = "kind")]
    pub bars: bool,

    /// Shortcut for --kind columns
    #[arg(short = 'C', group = "kind")]
    pub columns: bool,

    /// Shortcut for --kind braille
    #[arg(short = 'b', group = "kind")]
    pub braille: bool,

    /// Shortcut for --kind braille-columns
    #[arg(short = 'c', group = "kind")]
    pub braille_columns: bool,

    /// Path to file to read from (defaults to standard input)
    #[arg(short, long, conflicts_with = "modeline")]
    pub file: Option<std::path::PathBuf>,

    /// Use the full height if none given
    ///
    /// By default, space is given for the prompt (either at the terminal or through a pager like
    /// `less`). Use this flag to instead take up the full height given. Passing a size overrides
    /// this flag. Does nothing if the graph is not vertical.
    #[arg(long, env = "BRAILLE_USE_FULL_DEFAULT_HEIGHT", value_parser = BoolishValueParser::new())]
    pub use_full_default_height: bool,

    /// How wide or tall the graph can be (defaults to terminal size)
    #[arg(value_parser = clap::value_parser!(u16).range(1..))]
    pub size: Option<u16>,

    #[arg(skip)]
    pub first_line: Option<FirstLine>,
}

#[derive(Debug)]
pub enum FirstLine {
    ModeLine,
    Value(String),
}

pub trait Configurable: From<Opt> {
    fn kind(&self) -> GraphKind;
    fn style(&self) -> GraphStyle;
    fn minimum(&self) -> f64;
    fn maximum(&self) -> f64;
    fn size(&self) -> u16;
}

#[derive(Debug)]
pub struct Config {
    kind: GraphKind,
    style: GraphStyle,
    minimum: f64,
    maximum: f64,
    size: u16,
}

impl From<Opt> for Config {
    fn from(value: Opt) -> Self {
        if let (Some(min), Some(max)) = (value.range.min(), value.range.max()) {
            Self {
                kind: value.kind(),
                style: value.style,
                minimum: min,
                maximum: max,
                size: value.size.unwrap(),
            }
        } else {
            unreachable!("The bounds should already have been calculated")
        }
    }
}

impl Configurable for Config {
    fn kind(&self) -> GraphKind {
        self.kind
    }

    fn style(&self) -> GraphStyle {
        self.style
    }

    fn minimum(&self) -> f64 {
        self.minimum
    }

    fn maximum(&self) -> f64 {
        self.maximum
    }

    fn size(&self) -> u16 {
        self.size
    }
}

impl Opt {
    /// Parse options
    ///
    /// Call this instead of `Opt::parse()`, since it makes some adjustments not supported by
    /// [`clap`].
    pub fn try_new<I, S>(args: I) -> anyhow::Result<Self>
    where
        I: IntoIterator<Item = S>,
        S: Into<std::ffi::OsString> + Clone,
    {
        Self::try_new_from_reader(&mut std::io::stdin().lock(), args)
    }

    pub fn try_new_from_reader<I, S>(
        stdin: &mut impl std::io::BufRead,
        args: I,
    ) -> anyhow::Result<Self>
    where
        I: IntoIterator<Item = S>,
        S: Into<std::ffi::OsString> + Clone,
    {
        let mut opt = Self::parse_from(args);
        let use_full_default_height = opt.use_full_default_height;

        // Parse the modeline if requested
        if opt.modeline {
            use clap::{CommandFactory, FromArgMatches};
            let mut cmd = Self::command_for_update().no_binary_name(true);
            cmd.build();

            let mut first_line = String::new();
            stdin.read_line(&mut first_line)?;

            if let Some(args) = Self::parse_modeline(&mut cmd, first_line.trim())? {
                let matches = cmd.get_matches_from(args);

                opt = Self::from_arg_matches(&matches)?;
                opt.first_line = Some(FirstLine::ModeLine);
            } else {
                opt.first_line = Some(FirstLine::Value(first_line));
            }

            opt.use_full_default_height = use_full_default_height;
        } else {
            opt.first_line = None;
        }

        match (opt.kind(), opt.per) {
            (GraphKind::Bars | GraphKind::Columns, x) if x > 1 => {
                anyhow::bail!("Multiple values per line not supported for this graph kind");
            }
            _ => {}
        }

        // If the graph size isn't already set, try detecting it from the environment
        if opt.size.is_none() {
            let (width, height) = util::get_terminal_size()?;

            let size = match opt.kind().orientation() {
                Orientation::Horizontal => width,
                // Leave enough room for the shell prompt
                Orientation::Vertical => {
                    if opt.use_full_default_height {
                        height
                    } else {
                        height - 1
                    }
                }
            };

            opt.size = Some(size);
        }

        Ok(opt)
    }

    /// Parse the first line as a modeline, or try parsing it as the first value
    fn parse_modeline<'a>(
        cmd: &mut Command,
        line: &'a str,
    ) -> Result<Option<Vec<&'a str>>, clap::Error> {
        if line.starts_with('#') {
            Ok(Some(vec![]))
        } else if line.starts_with("braille") {
            let modeline = line
                .split_once('#')
                .map_or(line, |(s, _)| s)
                .trim_start_matches("braille")
                .split_ascii_whitespace()
                .collect();
            Ok(Some(modeline))
        } else if !line.is_empty() && line.parse::<f64>().is_err() {
            use clap::error::{ContextValue, ErrorKind};
            Err(cmd.error(
                ErrorKind::ValueValidation,
                ContextValue::String(format!(
                    r#"Invalid modeline: {line:?}

The first line should be the string "braille", followed by spaced separated options"#
                )),
            ))
        } else {
            Ok(None)
        }
    }

    /// Verify that min is less than max, bailing with an error if not
    fn validate_bounds(min: f64, max: f64) -> anyhow::Result<()> {
        if min > max {
            anyhow::bail!(
                "min < max failed: {} < {}",
                if min == f64::MAX {
                    "f64::MAX".to_string()
                } else {
                    min.to_string()
                },
                if max == f64::MIN {
                    "f64::MIN".to_string()
                } else {
                    max.to_string()
                },
            );
        }

        Ok(())
    }

    /// If no bounds were given, look for them from the input and return the resulting iterator,
    /// otherwise simply return the resulting iterator.
    pub fn get_iter<T>(&mut self, input_lines: InputLines<T>) -> anyhow::Result<ValueIter<T>>
    where
        InputLine<T>: FromStr + for<'a> InputLineSinglable<'a>,
        <InputLine<T> as FromStr>::Err: std::error::Error + Send + Sync + 'static,
    {
        if self.range.min().and(self.range.max()).is_some() {
            match self.kind() {
                GraphKind::Bars
                | GraphKind::BrailleBars
                | GraphKind::MiniBars
                | GraphKind::SextantBars
                | GraphKind::OctantBars => Ok(ValueIter::Boundless(input_lines.into_iter())),
                GraphKind::Columns
                | GraphKind::BrailleColumns
                | GraphKind::MiniColumns
                | GraphKind::SextantColumns
                | GraphKind::OctantColumns => Ok(ValueIter::Bounded {
                    lines: input_lines.into_iter().collect(),
                }),
            }
        } else {
            let mut lines = vec![];
            let has_min = self.range.min().is_some();
            let has_max = self.range.max().is_some();
            assert!(!has_min || !has_max);
            let mut min = self.range.min().unwrap_or(f64::MAX);
            let mut max = self.range.max().unwrap_or(f64::MIN);

            for line in input_lines {
                let line = line?;
                for value in line.as_single_iter().flatten() {
                    if !has_min {
                        min = min.min(*value);
                    }

                    if !has_max {
                        max = max.max(*value);
                    }
                }

                lines.push(Ok(line));
            }

            self.range = GraphRange::try_new(Some(min), Some(max))?;

            Ok(ValueIter::Bounded { lines })
        }
    }

    /// Get the kind of graph to use, handling shortcuts
    #[must_use]
    pub fn kind(&self) -> GraphKind {
        if self.bars {
            GraphKind::Bars
        } else if self.braille {
            GraphKind::BrailleBars
        } else if self.braille_columns {
            GraphKind::BrailleColumns
        } else if self.columns {
            GraphKind::Columns
        } else {
            self.graph_kind
        }
    }

    #[must_use]
    pub fn pre_min(&self) -> Option<f64> {
        self.range.min()
    }

    #[must_use]
    pub fn pre_max(&self) -> Option<f64> {
        self.range.max()
    }
}

pub enum ValueIter<T>
where
    InputLine<T>: FromStr,
{
    Boundless(InputLines<T>),
    Bounded { lines: Vec<LineResult<T>> },
}

impl<T: 'static> IntoIterator for ValueIter<T>
where
    InputLine<T>: FromStr,
{
    type Item = LineResult<T>;

    type IntoIter = Box<dyn Iterator<Item = Self::Item>>;

    fn into_iter(self) -> Self::IntoIter {
        match self {
            ValueIter::Boundless(lines) => Box::new(lines),
            ValueIter::Bounded { lines } => Box::new(lines.into_iter()),
        }
    }
}

#[derive(Debug, Default, Clone, Copy, ValueEnum)]
pub enum GraphKind {
    /// ‚ñà‚ñâ‚ñä‚ñã‚ñå‚ñç‚ñé‚ñè Bar graph with block characters
    #[value(alias = "B")]
    Bars,

    /// ‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà Column graph with block characters
    #[value(alias = "C")]
    Columns,

    /// ‚ñô Bar graph using mini block characters
    #[value(alias = "mb")]
    MiniBars,

    /// ‚ñü Column graph using mini block characters
    #[value(alias = "mc")]
    MiniColumns,

    /// ‚†ô‚£á Bar graph with braille characters
    ///
    /// Example plotting integers in \[-2, 1\]:
    ///
    /// ```plain
    ///    A  ** *-
    /// x  B  -* *-
    /// ‚Üì  C  -- *-
    ///    D  -- **
    ///
    ///      -2  0
    ///
    ///        y ‚Üí
    /// ```
    #[default]
    #[value(name = "braille", aliases = ["b", "braille-bars"])]
    BrailleBars,

    /// ‚°∂‚†ö Column graph with braille characters
    ///
    /// Example plotting integers in \[-2, 1\]:
    ///
    /// ```plain
    ///     1  -- -*
    /// ‚Üë   0  ** **
    /// y  -1  ** --
    ///    -2  *- --
    ///
    ///        AB CD
    ///
    ///         x ‚Üí
    /// ```
    #[value(alias = "c")]
    BrailleColumns,

    /// ü¨∫ü¨è Bar graph using sextant (2x3) characters
    SextantBars,

    /// ü¨µ‚ñå Column graph using sextant (2x3) characters
    SextantColumns,

    /// Bar graph using octant (2x4) characters
    OctantBars,

    /// Column graph using octant (2x4) characters
    OctantColumns,
}

#[derive(Debug, Clone, Copy)]
pub enum Orientation {
    Horizontal,
    Vertical,
}

impl GraphKind {
    #[must_use]
    pub fn orientation(self) -> Orientation {
        match self {
            GraphKind::Bars
            | GraphKind::MiniBars
            | GraphKind::BrailleBars
            | GraphKind::SextantBars
            | GraphKind::OctantBars => Orientation::Horizontal,
            GraphKind::Columns
            | GraphKind::MiniColumns
            | GraphKind::BrailleColumns
            | GraphKind::SextantColumns
            | GraphKind::OctantColumns => Orientation::Vertical,
        }
    }

    #[must_use]
    pub fn char_type(self) -> CharType {
        match self {
            Self::Bars => CharType::Block,
            Self::Columns => CharType::Column,
            Self::BrailleBars | Self::BrailleColumns => CharType::Braille,
            Self::MiniBars | Self::MiniColumns => CharType::HalfBlock,
            Self::OctantBars | Self::OctantColumns => CharType::Octant,
            Self::SextantBars | Self::SextantColumns => CharType::Sextant,
        }
    }
}

#[derive(Debug, Clone, Copy)]
pub enum CharType {
    Block,
    Column,
    Braille,
    HalfBlock,
    Sextant,
    Octant,
}

#[cfg(test)]
mod tests {
    use super::*;
    use clap::CommandFactory;

    #[test]
    fn opt_sanity_check() {
        Opt::command().debug_assert();
    }

    mod graph_range {
        use super::*;

        macro_rules! terr {
            ($name:ident, $input:literal) => {
                #[test]
                fn $name() {
                    assert!($input.parse::<GraphRange>().is_err());
                }
            };
        }

        macro_rules! t {
            ($name:ident, $($args:tt)+) => {
                #[test]
                fn $name() {
                    t!($($args)+);
                }
            };

            (max $max:literal, $input:literal) => {
                assert_eq!(
                    GraphRange::try_new(None, Some($max)).unwrap(),
                    $input.parse().unwrap()
                );
            };

            (min $min:literal, $input:literal) => {
                assert_eq!(
                GraphRange::try_new(Some($min), None).unwrap(),
                $input.parse().unwrap()
                )
            };

            ($min:literal, $max:literal, $input:literal) => {
                assert_eq!(
                    GraphRange::try_new(Some($min), Some($max)).unwrap(),
                    $input.parse().unwrap()
                );
            };
        }

        #[test]
        fn parse_default_graph_range() {
            let expected = GraphRange {
                min: GraphRangeBound(None),
                max: GraphRangeBound(None),
            };
            let actual = ":".parse::<GraphRange>().unwrap();
            assert_eq!(expected, actual);
        }

        t!(parse_full_bounds, -4., 5., "-4:5");
        t!(parse_open_upper_bound, min 3., "3:");
        t!(parse_open_lower_bound, max 3., ":3");

        terr!(parse_invalid, "hello");
        terr!(parse_invalid_upper, ":hello");
        terr!(parse_invalid_lower, "hello:");
        terr!(parse_backwards, "3:2");
    }
}
